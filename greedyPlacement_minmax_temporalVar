function [chosenEdges, history] = greedyPlacement_minmax_temporalVar( ...
    candidateEdges, taskPaths, OD, dist, ...
    consRate, numEVs, minSOC, maxSOC, chargeThreshold, stopSOC, ...
    numStations, wCharge, wStop, wVar, maxGreedyIter, battery_kWh, ...
    baseLoad24h, edgeToBus)

% GREEDY EVFCS PLACEMENT WITH MIN–MAX NORMALISATION (3 OBJECTIVES)
% Variance = temporal variance of station load over 24 hours

epsNorm = 1e-9;

remainingEdges = candidateEdges;
chosenEdges = zeros(0,2);
iter = 0;

history.C = {};
history.S = {};
history.V = {};
history.Cn = {};
history.Sn = {};
history.Vn = {};
history.score = [];
history.edge = {};

fprintf('\n[Greedy-MinMax-3OBJ] Starting greedy placement\n');

while size(chosenEdges,1) < numStations && ...
      ~isempty(remainingEdges) && ...
      iter < maxGreedyIter

    iter = iter + 1;
    nCand = size(remainingEdges,1);

    C = zeros(nCand,1);
    S = zeros(nCand,1);
    V = zeros(nCand,1);

    for e = 1:nCand
        trialEdges = [chosenEdges; remainingEdges(e,:)];

        [C(e), S(e), V(e)] = simulateWithStationsTemporalVar( ...
            trialEdges, taskPaths, OD, dist, ...
            consRate, numEVs, minSOC, maxSOC, ...
            chargeThreshold, stopSOC, battery_kWh, ...
            baseLoad24h, edgeToBus);
    end

    % --- MIN–MAX NORMALISATION ---
    Cn = minmaxNorm(C, epsNorm);
    Sn = minmaxNorm(S, epsNorm);
    Vn = minmaxNorm(V, epsNorm);

    score = wCharge*Cn - wStop*Sn - wVar*Vn;

    [bestScore, idx] = max(score);
    bestEdge = remainingEdges(idx,:);

    % log
    history.C{iter} = C;
    history.S{iter} = S;
    history.V{iter} = V;
    history.Cn{iter} = Cn;
    history.Sn{iter} = Sn;
    history.Vn{iter} = Vn;
    history.score(iter) = bestScore;
    history.edge{iter} = bestEdge;

    fprintf(['Selected station %d: edge %d->%d | ', ...
             'trialCharge=%.2f trialStops=%d trialVar=%.2f score=%.4f\n'], ...
        iter, bestEdge(1), bestEdge(2), ...
        C(idx), S(idx), V(idx), bestScore);

    chosenEdges = [chosenEdges; bestEdge];
    remainingEdges(idx,:) = [];
end

fprintf('[Greedy-MinMax-3OBJ] Finished. Selected %d stations.\n', size(chosenEdges,1));
end

% ======================= HELPERS =======================

function xnorm = minmaxNorm(x, epsNorm)
xmin = min(x);
xmax = max(x);
if abs(xmax - xmin) < epsNorm
    xnorm = zeros(size(x));
else
    xnorm = (x - xmin) ./ (xmax - xmin);
end
end

% ======================= TEMPORAL VAR SIM =======================

function [totalCharge_kWh, totalStops, busVar] = ...
    simulateWithStationsTemporalVar(stationEdges, taskPaths, OD, dist, ...
        consRate, numEVs, minSOC, maxSOC, ...
        chargeThreshold, stopSOC, battery_kWh, ...
        baseLoad24h, edgeToBus)

K = size(stationEdges,1);
totalCharge_pct = 0;
totalStops = 0;

stationEnergyPerHour = zeros(K,24);

if K == 0
    totalCharge_kWh = 0;
    busVar = 0;
    return;
end

keys = arrayfun(@(i) sprintf('%d-%d',stationEdges(i,1),stationEdges(i,2)), ...
                1:K,'UniformOutput',false);

for hr = 1:24
    for t = 1:numel(taskPaths)
        p = taskPaths{t};
        if isempty(p), continue; end

        soc = minSOC + (maxSOC-minSOC).*rand(numEVs,1);
        stopped = false(numEVs,1);

        for k = 1:(numel(p)-1)
            u=p(k); v=p(k+1); d=dist(u,v);

            idx = find(strcmp(keys,sprintf('%d-%d',u,v)) | ...
                       strcmp(keys,sprintf('%d-%d',v,u)),1);

            if ~isempty(idx)
                distRem = sum(arrayfun(@(x) dist(p(x),p(x+1)), k:numel(p)-1));
                neededSOC = distRem * consRate;

                mask = soc < chargeThreshold;
                charge = max(0, neededSOC - soc(mask));
                soc(mask) = soc(mask) + charge;

                stationEnergyPerHour(idx,hr) = ...
                    stationEnergyPerHour(idx,hr) + sum(charge)/100*battery_kWh;

                totalCharge_pct = totalCharge_pct + sum(charge);
            end

            soc = soc - d*consRate;
            newStops = (soc < stopSOC) & ~stopped;
            totalStops = totalStops + sum(newStops);
            stopped(newStops) = true;
            soc(stopped) = stopSOC;
        end
    end
end

totalCharge_kWh = totalCharge_pct/100 * battery_kWh;

% === VARIANCE LOGIC YOU ASKED FOR ===
perStationVar = var(stationEnergyPerHour,0,2);
busVar = mean(perStationVar);

end
