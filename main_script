clc; clear; close all;
rng(70);   % fixed seed for reproducibility

%% =========================================================
%% 1. SHORTEST PATHS (YOUR WORKING FILE – UNCHANGED)
%% =========================================================
M = readmatrix('distance_matrix.xlsx');
M(M==0) = Inf;
M(1:size(M,1)+1:end) = 0;

[dist, nextHop] = floydWarshallNextHop(M);

%% =========================================================
%% 2. READ OD PAIRS (UNCHANGED LOGIC)
%% =========================================================
txt = extractFileText('OD nodes.docx');
pairs = regexp(txt,'\((\d+)\s*,\s*(\d+)\)','tokens');

OD = cellfun(@(c)[str2double(c{1}) str2double(c{2})], ...
             pairs, 'UniformOutput', false);
OD = vertcat(OD{:});

%% =========================================================
%% 3. BUILD TASK PATHS (UNCHANGED)
%% =========================================================
taskPaths = cell(size(OD,1),1);
for i = 1:size(OD,1)
    taskPaths{i} = localPath(OD(i,1), OD(i,2), nextHop);
end

%% =========================================================
%% 4. CANDIDATE EDGES (UNCHANGED)
%% =========================================================
candidateEdges = [];
for i = 1:numel(taskPaths)
    p = taskPaths{i};
    if numel(p) > 1
        candidateEdges = [candidateEdges; [p(1:end-1)' p(2:end)']];
    end
end
candidateEdges = unique(candidateEdges,'rows');
fprintf('Found %d candidate edges from tasks.\n', size(candidateEdges,1));

%% =========================================================
%% 5. LOAD POWER DATA (NEW – REQUIRED FOR TEMPORAL VARIANCE)
%% =========================================================

% --- IEEE 69-bus 24h active power data (69 x 24)
baseLoad24h = readmatrix('IEEE69_24h active data.xlsx');

% --- Edge → Bus mapping
% Expected format: [fromNode  toNode  busIndex]
edgeToBus = readmatrix('Bus to edge mapping.xlsx');

%% =========================================================
%% 5B. LOAD HOURLY VEHICLE FLOW (PER-UNIT → ABSOLUTE)
%% =========================================================

% 24 × 1 per-unit vehicle flow (0–1)
vehFlow_pu = readmatrix('24hr_vehicles.xlsx');

if numel(vehFlow_pu) ~= 24
    error('Vehicle flow file must contain 24 hourly values');
end

maxEVsPerHour = 5;                % p.u. = 1 corresponds to 50 EVs
numEVs_hourly = round(maxEVsPerHour * vehFlow_pu(:));

fprintf('Hourly EV flow loaded (max = %d EV/h)\n', maxEVsPerHour);

%% =========================================================
%% 6. PARAMETERS (SAME AS YOUR OLD CODE)
%% =========================================================
consRate = 1;

minSOC = 60;
maxSOC = 85;
chargeThreshold = 55;
stopSOC = 20;

battery_kWh = 59;

numStations = 6;

wCharge = 8.431;
wStop   = 8.709;
wVar    = 1.092;

maxGreedyIter = 1000;
disp(numEVs_hourly.')

%% =========================================================
%% 7. RUN GREEDY (UPDATED CALL SIGNATURE)
%% =========================================================
[chosenEdges, history] = greedyPlacement_minmax_temporalVar( ...
    candidateEdges, taskPaths, OD, dist, ...
    consRate, numEVs_hourly, minSOC, maxSOC, ...
    chargeThreshold, stopSOC, ...
    numStations, wCharge, wStop, wVar, ...
    maxGreedyIter, battery_kWh, ...
    baseLoad24h, edgeToBus);


%% =========================================================
%% 8. FINAL OUTPUT
%% =========================================================
disp('Selected EVFCS edges:');
disp(chosenEdges);

%% =========================================================
%% LOCAL HELPER (UNCHANGED)
%% =========================================================
function path = localPath(u, v, nextHop)
path = u;
while u ~= v
    u = nextHop(u, v);
    if u == 0
        path = [];
        return;
    end
    path(end+1) = u; %#ok<AGROW>
end
end


%% =========================================================
%% 9. CHARGE SOLD & TIME PER STATION
%% =========================================================

%% =========================================================
%% RUN STATION SALES & TIME SIMULATION
%% =========================================================

stationStats = simulateStationSalesAndTime( ...
    chosenEdges, taskPaths, dist, ...
    consRate, numEVs_hourly, ...
    minSOC, maxSOC, ...
    chargeThreshold, stopSOC, ...
    battery_kWh);

%% =========================================================
%% PRINT RESULTS
%% =========================================================

fprintf('\n=== STATION SALES SUMMARY ===\n');
for k = 1:numel(stationStats)
    fprintf(['Station %d (edge %d->%d): ', ...
             'ChargeSold = %.2f kWh | ', ...
             'AvgChargeTime = %.2f min | ', ...
             'AvgEnergy/EV = %.2f kWh | ', ...
             'Sessions = %d\n'], ...
        k, ...
        stationStats(k).edge(1), stationStats(k).edge(2), ...
        stationStats(k).chargeSold_kWh, ...
        stationStats(k).avgChargingTime_min, ...
        stationStats(k).avgEnergyPerEV_kWh, ...
        stationStats(k).numCharges);
end
speed_kmh = 60;
kmPerUnit = 2;
portsPerStation = [4 2 2 1 1 3];


%% =========================================================
%% 10. COMPUTE REQUIRED NUMBER OF CHARGING PORTS
%% =========================================================

maxPortHours = 10;  
portStats = computeChargingPorts(stationStats, maxPortHours);

fprintf('\n=== CHARGING PORT REQUIREMENTS (Max port usage = %.1f hr) ===\n', ...
        maxPortHours);
for s = 1:numel(portStats)
    fprintf(['Station %d (edge %d->%d): ', ...
             'Ports = %d | Avg port usage = %.2f hr | Utilization = %.1f%%\n'], ...
        portStats(s).stationID, ...
        portStats(s).edge(1), portStats(s).edge(2), ...
        portStats(s).numPorts, ...
        portStats(s).avgPortUsage_hr, ...
        portStats(s).utilization_pct);
end


% ================= EV TIMELINE PARAMETERS =================
kmPerUnit      = 2;        % km per distance unit
speed_kmh      = 60;       % EV speed
chargerPower_kW = 180;      % DC fast charger power

% ports per station (same order as chosenEdges)
% =========================================================
% EV ARRIVAL – WAITING – DEPARTURE TIME SIMULATION
% =========================================================

%% =========================================================
%% 11. EV TIMELINE
%% =========================================================
[EVevents, EVsummary] = simulateEVTimeline( ...
    OD, taskPaths, chosenEdges, dist, ...
    numEVs_hourly, kmPerUnit, speed_kmh, ...
    minSOC, maxSOC, chargeThreshold, stopSOC, consRate, ...
    battery_kWh, chargerPower_kW, portsPerStation);

%% =========================================================
%% 12. EVFCS POWER TIMELINE
%% =========================================================

generateEVFCSArrivalAndPowerTimeline_10min( ...
    EVevents, chosenEdges, portsPerStation, battery_kWh);


%% =========================================================
%% 13. Optimising the weights in greedy algorithm
%% =========================================================
%{
best = randomWeightSearch_MaxEnergy( ...
    50, ...                       % number of random trials
    candidateEdges, taskPaths, OD, dist, ...
    consRate, numEVs_hourly, minSOC, maxSOC, ...
    chargeThreshold, stopSOC, ...
    6, ...                        % number of EVFCS
    20, ...                       % max greedy iterations
    battery_kWh, ...
    baseLoad24h, edgeToBus, ...
    kmPerUnit, speed_kmh, portsPerStation);
%}

%% =========================================================
%% 14. Battery Scheduling Algorithm
%% =========================================================

%% ---------------------------
% BATTERY PARAMETERS
% ---------------------------
E_BESS  = 500;    % kWh
beta_ch = 150;    % kW
eta_BC  = 0.95;   % efficiency

EV_file  = 'EVFCS_10min_Arrival_Power.xlsx';
PV_file  = 'PV_Results_6_NPV_10min.xlsx';
RTP_file = 'RTP_grid_cost_10min.xlsx';

sheetNames_EV = { ...
    'EVFCS_1_6_8', ...
    'EVFCS_2_12_13', ...
    'EVFCS_3_21_20', ...
    'EVFCS_4_6_5', ...
    'EVFCS_5_6_2', ...
    'EVFCS_6_11_12' };

sheetNames_PV = { ...
    'NPV_400', ...
    'NPV_390', ...
    'NPV_420', ...
    'NPV_405', ...
    'NPV_397', ...
    'NPV_408' };

%% ------------------------
% RUN BSA
% ------------------------
BSA = BSA_step1_step2( ...
        EV_file, PV_file, RTP_file, ...
        sheetNames_EV, sheetNames_PV);

dt = 1/6;
nFCS = numel(BSA.P_EV);
Nslots = numel(BSA.P_EV{1});

fprintf('BSA executed successfully.\n');

%% ========================================================
% 1️⃣ VERIFY MUTUAL EXCLUSIVITY (CRITICAL)
% ========================================================

fprintf('\nChecking mutual exclusivity...\n');

for i = 1:nFCS
    simultaneous = find( ...
        (BSA.P_BC{i} > 0) & (BSA.P_BD{i} > 0) );

    if isempty(simultaneous)
        fprintf('FCS %d: OK (no simultaneous charge/discharge)\n', i);
    else
        error('FCS %d violates exclusivity at slots: %s', ...
              i, mat2str(simultaneous));
    end
end

%% ========================================================
% 2️⃣ VERIFY GRID-BASED OPERATING REGIONS
% ========================================================

fprintf('\nChecking grid operating regions...\n');

for i = 1:nFCS

    Net_Load = BSA.P_EV{i} - BSA.P_PV_avg{i};

    % Charging should happen only when Net_Load <= P_CD
    badCharge = find( ...
        (BSA.P_BC{i} > 0) & (Net_Load > BSA.P_CD(i)) );

    % Discharging should happen only when Net_Load > P_CD
    badDischarge = find( ...
        (BSA.P_BD{i} > 0) & (Net_Load <= BSA.P_CD(i)) );

    if isempty(badCharge) && isempty(badDischarge)
        fprintf('FCS %d: Grid conditions respected\n', i);
    else
        error('FCS %d violates grid condition logic', i);
    end
end

%% ========================================================
% 3️⃣ VERIFY SOC BOUNDS
% ========================================================

fprintf('\nChecking SOC bounds...\n');

for i = 1:nFCS
    if all(BSA.SOC{i} >= BSA.SOC_min & BSA.SOC{i} <= BSA.SOC_max)
        fprintf('FCS %d: SOC bounds respected\n', i);
    else
        error('FCS %d SOC out of bounds', i);
    end
end

%% ========================================================
% 4️⃣ VISUAL VERIFICATION (PLOTS)
% ========================================================

i = 1;  % choose one station to visualize
t = (0:Nslots-1) * dt;

figure('Name','BSA Verification','Color','w');

subplot(3,1,1)
plot(t, BSA.P_EV{i}, 'k', 'LineWidth',1.2); hold on;
plot(t, BSA.P_PV_avg{i}, 'g', 'LineWidth',1.2);
yline(BSA.P_CD(i),'r--','LineWidth',1.2);
ylabel('Power (kW)')
title('EV Load, PV Generation, Contract Demand')
legend('EV','PV','P_{CD}')

subplot(3,1,2)
stairs(t, BSA.P_BC{i}, 'b', 'LineWidth',1.2); hold on;
stairs(t, BSA.P_BD{i}, 'r', 'LineWidth',1.2);
ylabel('Battery Power (kW)')
legend('Charging','Discharging')
title('Battery Charging / Discharging (Mutually Exclusive)')


subplot(3,1,3)
plot(t, BSA.SOC{i}(1:end-1), 'm', 'LineWidth',1.2);
ylim([BSA.SOC_min-5 BSA.SOC_max+5])
ylabel('SOC (%)')
title('State of Charge')



fprintf('\nVerification completed successfully.\n');


% ---------------------------------------------------------

% ---------------------------------------------------------
% STEP-5: Generate Excel
% ---------------------------------------------------------
% -----------------------------------------
% STEP 5: Power, energy & Excel
% -----------------------------------------
outputExcel = 'BSA_Results_10min.xlsx';

BSA = BSA_step5_generateExcel(BSA, outputExcel);

fprintf('✔ STEP-5 completed successfully\n');


